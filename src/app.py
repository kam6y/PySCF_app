import streamlit as st
import numpy as np
import pandas as pd
from pyscf import gto, dft
from rdkit import Chem
from rdkit.Chem import AllChem
import py3Dmol
import os

def get_molecule_from_smiles(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return None, None, None
    mol = Chem.AddHs(mol)
    AllChem.EmbedMolecule(mol, randomSeed=42)
    AllChem.MMFFOptimizeMolecule(mol)
    atoms = []
    coords = []
    for atom in mol.GetAtoms():
        pos = mol.GetConformer().GetAtomPosition(atom.GetIdx())
        atoms.append(atom.GetSymbol())
        coords.append([pos.x, pos.y, pos.z])
    return mol, atoms, np.array(coords)

def get_molecule_from_xyz(xyz_string):
    lines = xyz_string.strip().split('\n')
    try:
        n_atoms = int(lines[0])
        atoms = []
        coords = []
        for i in range(2, 2 + n_atoms):
            if i >= len(lines):
                break
            parts = lines[i].split()
            if len(parts) >= 4:
                atom_symbol = parts[0]
                x, y, z = float(parts[1]), float(parts[2]), float(parts[3])
                atoms.append(atom_symbol)
                coords.append([x, y, z])
        return atoms, np.array(coords)
    except:
        return None, None

def save_xyz_file(atoms, coords, filename='molecule.xyz'):
    os.makedirs('data', exist_ok=True)
    filepath = os.path.join('data', filename)
    with open(filepath, 'w') as f:
        f.write(f"{len(atoms)}\n")
        f.write("Generated by Molecular DFT App\n")
        for i, atom in enumerate(atoms):
            f.write(f"{atom} {coords[i][0]:.6f} {coords[i][1]:.6f} {coords[i][2]:.6f}\n")
    return filepath

def run_dft_calculation(atoms, coords, basis, xc_functional, charge, spin):
    from pyscf import geomopt
    conv_params = {
        'convergence_energy': 1e-6,  # エネルギーの収束閾値 (Eh)
        'convergence_grms': 3e-4,    # 勾配のRMS収束閾値 (Eh/Bohr)
        'convergence_gmax': 4.5e-4,  # 最大勾配の収束閾値 (Eh/Bohr)
        'convergence_drms': 1.2e-3,  # 変位のRMS収束閾値 (Angstrom)
        'convergence_dmax': 1.8e-3   # 最大変位の収束閾値 (Angstrom)
    }
    mol_input = []
    for i, atom in enumerate(atoms):
        mol_input.append([atom, coords[i].tolist()])
    mol = gto.M(atom=mol_input, basis=basis, charge=charge, spin=spin)
    mf = dft.RKS(mol)
    mf.xc = xc_functional
    # SCFオブジェクトを渡して最適化
    mol_opt = geomopt.optimize(mf, conv_params=conv_params)
    mf_opt = dft.RKS(mol_opt)
    mf_opt.xc = xc_functional
    mf_opt.verbose = 0
    energy = mf_opt.kernel()
    homo_idx = mol_opt.nelectron // 2 - 1
    lumo_idx = homo_idx + 1
    mo_energy = mf_opt.mo_energy
    homo_energy = mo_energy[homo_idx]
    lumo_energy = mo_energy[lumo_idx]
    gap = lumo_energy - homo_energy
    orbital_energies = pd.DataFrame({
        '軌道番号': range(len(mo_energy)),
        'エネルギー (eV)': mo_energy * 27.211386
    })
    population = mf_opt.mulliken_pop()
    charges = population[1]
    # 最適化後のxyz文字列を生成
    atom_syms = [a[0] for a in mol_opt._atom]
    atom_coords = mol_opt.atom_coords()
    xyz_lines = [f"{atom_syms[i]} {atom_coords[i][0]:.6f} {atom_coords[i][1]:.6f} {atom_coords[i][2]:.6f}" for i in range(len(atom_syms))]
    xyz_optimized = f"{len(atom_syms)}\nOptimized by PySCF\n" + "\n".join(xyz_lines)
    return {
        'energy': energy,
        'homo': homo_energy * 27.211386,
        'lumo': lumo_energy * 27.211386,
        'gap': gap * 27.211386,
        'orbital_energies': orbital_energies,
        'charges': charges,
        'mol': mol_opt,
        'xyz_optimized': xyz_optimized,
        'mf_opt': mf_opt  # 追加: 最適化後のSCFオブジェクト
    }

def plot_mo_energies_plotly(orbital_energies, homo_idx, gap=None):
    import plotly.graph_objects as go
    df = orbital_energies.copy()
    df['タイプ'] = 'MO'
    df.at[homo_idx, 'タイプ'] = 'HOMO'
    df.at[homo_idx+1, 'タイプ'] = 'LUMO'
    colors = {'MO': 'gray', 'HOMO': 'blue', 'LUMO': 'red'}
    fig = go.Figure()
    # HOMO/LUMOを太く、他は細く
    for i, row in df.iterrows():
        color = colors.get(row['タイプ'], 'gray')
        width = 6 if row['タイプ'] in ['HOMO', 'LUMO'] else 2
        fig.add_shape(type="line",
            x0=0.3, x1=0.7,
            y0=row['エネルギー (eV)'], y1=row['エネルギー (eV)'],
            line=dict(color=color, width=width),
            layer="above"
        )
        fig.add_trace(go.Scatter(
            x=[0.5], y=[row['エネルギー (eV)']],
            mode='markers+text',
            marker=dict(color=color, size=12 if row['タイプ'] in ['HOMO','LUMO'] else 7),
            text=[row['タイプ'] if row['タイプ'] in ['HOMO','LUMO'] else ''],
            textposition="middle right",
            showlegend=False,
            hoverinfo='text',
            hovertext=f"{row['タイプ']}<br>軌道番号: {row['軌道番号']}<br>エネルギー: {row['エネルギー (eV)']:.4f} eV"
        ))
    # HOMO-LUMO gap矢印
    homo_e = df.at[homo_idx, 'エネルギー (eV)']
    lumo_e = df.at[homo_idx+1, 'エネルギー (eV)']
    gap_value = gap if gap is not None else lumo_e - homo_e
    fig.add_annotation(
        x=0.85, y=(homo_e + lumo_e)/2,
        ax=0.85, ay=homo_e,
        xref='x', yref='y', axref='x', ayref='y',
        text=f"GAP: {gap_value:.2f} eV",
        showarrow=True,
        arrowhead=2,
        arrowsize=1.5,
        arrowwidth=2,
        arrowcolor="green",
        font=dict(color="green", size=14),
        align="center",
        bgcolor="white",
        bordercolor="green"
    )
    # HOMO/LUMOラベル
    fig.add_annotation(x=0.9, y=homo_e, text=f"HOMO: {homo_e:.2f} eV", showarrow=False, font=dict(color="blue", size=13), bgcolor="white")
    fig.add_annotation(x=0.9, y=lumo_e, text=f"LUMO: {lumo_e:.2f} eV", showarrow=False, font=dict(color="red", size=13), bgcolor="white")
    fig.update_layout(
        xaxis=dict(showticklabels=False, showgrid=False, zeroline=False, range=[0, 1]),
        yaxis=dict(title='エネルギー (eV)', zeroline=True, showgrid=True, gridcolor='lightgray'),
        height=500,
        margin=dict(l=40, r=40, t=60, b=40),
        plot_bgcolor='white',
    )
    return fig

def run_and_plot_ir_spectrum(mf_opt, mol, atoms):
    """
    IRスペクトルの計算・描画・ピーク表生成を行い、結果を辞書で返す。
    エラー時は'detail'にエラーメッセージを格納。
    """
    from pyscf.prop import infrared
    from pyscf.hessian import thermo
    import io
    import base64
    import matplotlib.pyplot as plt
    import sys
    result = {}
    try:
        mf_ir = infrared.rks.Infrared(mf_opt).run()
        sys_stdout = sys.stdout
        thermo_text = io.StringIO()
        sys.stdout = thermo_text
        try:
            thermo.dump_thermo(mol, thermo.thermo(mf_opt, mf_ir.vib_dict["freq_au"], 298.15, 101325))
        except Exception:
            pass
        sys.stdout = sys_stdout
        result['thermo_text'] = thermo_text.getvalue()
        # 振動数のスケーリングファクターとして0.960を適用
        fig, ax, ax2 = mf_ir.plot_ir(w=100, scale=0.960)
        ax.set_title("Infrared Spectrum (B3LYP, scale=0.960, FWHM=100 cm$^{-1}$)")
        fig.tight_layout()
        buf = io.BytesIO()
        fig.savefig(buf, format='png')
        buf.seek(0)
        img_base64 = base64.b64encode(buf.read()).decode()
        plt.close(fig)
        result['img_base64'] = img_base64
        # IRピークと振動モードの対応表
        freq = mf_ir.vib_dict.get("freq_wavenumber")  # cm^-1
        intensity = getattr(mf_ir, "ir_inten", None)  # IR強度 (km/mol)
        normal_modes = mf_ir.vib_dict.get("norm_mode")
        if freq is not None and intensity is not None and normal_modes is not None:
            mode_info = []
            for idx in range(len(freq)):
                mode_info.append({
                    '周波数 (cm⁻¹)': f"{freq[idx]:.1f}",
                    '強度 (km/mol)': f"{intensity[idx]:.1f}",
                })
            import pandas as pd
            mode_df = pd.DataFrame(mode_info)
            result['mode_df'] = mode_df
        else:
            result['mode_df'] = None
        result['detail'] = None
    except Exception as e:
        result['detail'] = str(e)
    return result

st.set_page_config(page_title="分子構造DFT計算", layout="wide")
st.title('分子構造DFT計算')
st.markdown("主に PySCF と Streamlit を使用")
st.markdown("計算時間と精度は選択した計算設定に依存します。かなり弱いCPUで計算しているので計算設定がリッチだと計算が終わらずにエラーを吐く場合があります。")
st.markdown("---")

# --- セッションステート初期化 ---
if 'xyz_string' not in st.session_state:
    st.session_state['xyz_string'] = ''

# --- サイドバーで分子構造入力 ---
st.sidebar.title('分子構造入力')
input_method = st.sidebar.radio('**入力方法**', ['PubChem名/IDから取得', 'SMILESから取得'], index=0)
if input_method == 'PubChem名/IDから取得':
    pubchem_query = st.sidebar.text_input('化合物名またはCID', key='pubchem_sidebar')
    if st.sidebar.button('PubChemから取得', key='pubchem_btn') and pubchem_query:
        import pubchempy as pcp
        try:
            c = pcp.get_compounds(pubchem_query, 'name')
            if not c:
                c = pcp.get_compounds(pubchem_query, 'cid')
            if c:
                mol = c[0]
                smiles = mol.isomeric_smiles or mol.canonical_smiles
                if smiles:
                    mol_rdkit, atoms, coords = get_molecule_from_smiles(smiles)
                    if mol_rdkit is not None:
                        xyz = f"{len(atoms)}\nPubChemから取得(RDKit再構造化)\n" + '\n'.join([
                            f"{a} {c[0]:.6f} {c[1]:.6f} {c[2]:.6f}" for a, c in zip(atoms, coords)
                        ])
                        st.session_state['xyz_string'] = xyz
                        st.sidebar.success('PubChemから取得・3D再構造化成功')
                    else:
                        st.sidebar.error('SMILESから3D構造生成に失敗しました')
                else:
                    st.sidebar.error('PubChemからSMILESが取得できませんでした')
            else:
                st.sidebar.error('該当する化合物が見つかりません')
        except Exception as e:
            st.sidebar.error(f'PubChem取得エラー: {e}')
elif input_method == 'SMILESから取得':
    smiles = st.sidebar.text_input('SMILES', key='smiles_sidebar')
    if st.sidebar.button('SMILESから変換', key='smiles_btn') and smiles:
        mol, atoms, coords = get_molecule_from_smiles(smiles)
        if mol is not None:
            xyz = f"{len(atoms)}\nSMILESから生成\n" + '\n'.join([
                f"{a} {c[0]:.6f} {c[1]:.6f} {c[2]:.6f}" for a, c in zip(atoms, coords)
            ])
            st.session_state['xyz_string'] = xyz
            st.sidebar.success('SMILESからXYZ変換成功')
        else:
            st.sidebar.error('SMILESの解釈に失敗しました')

st.sidebar.title('計算設定')
basis_set = st.sidebar.selectbox('基底関数セット:', ['sto-3g', '3-21g', '6-31g', 'cc-pvdz', 'cc-pvtz'], index=0)
functional = st.sidebar.selectbox('交換相関汎関数:', ['b3lyp', 'pbe', 'pbe0', 'lda', 'm06'], index=0)
charge = st.sidebar.number_input('分子の電荷:', min_value=-5, max_value=5, value=0, step=1)
spin = st.sidebar.number_input('スピン多重度 (2S+1):', min_value=1, max_value=6, value=1, step=1)

# XYZ直接入力/編集欄をサイドバーの下部に移動
st.sidebar.markdown('**XYZ直接入力/編集**')
xyz_string = st.sidebar.text_area('XYZ座標', st.session_state['xyz_string'], height=200, key='xyz_input_sidebar')
st.session_state['xyz_string'] = xyz_string

# --- XYZの統合 ---
xyz_final = st.session_state['xyz_string']

atoms, coords = None, None
if xyz_final:
    atoms, coords = get_molecule_from_xyz(xyz_final)

# --- py3Dmol描画もXYZ直接入力/編集欄の内容のみ参照 ---
if st.session_state['xyz_string']:
    atoms, coords = get_molecule_from_xyz(st.session_state['xyz_string'])
    if atoms is not None and coords is not None:
        st.subheader('3D分子構造')
        xyz_block = f"{len(atoms)}\n\n" + '\n'.join([
            f"{a} {c[0]:.6f} {c[1]:.6f} {c[2]:.6f}" for a, c in zip(atoms, coords)
        ])
        view = py3Dmol.view(width=400, height=400)
        view.addModel(xyz_block, 'xyz')
        view.setStyle({'stick': {}})
        view.zoomTo()
        st.components.v1.html(view._make_html(), height=420)
        # --- DFT計算結果をセッションに保存し、ダウンロードボタンは常に表示 ---
        if 'dft_result' not in st.session_state:
            st.session_state['dft_result'] = None
        if st.button('DFT計算を実行', key='run_dft'):
            with st.spinner('計算実行中...'):
                try:
                    result = run_dft_calculation(atoms, coords, basis_set, functional, charge, spin-1)
                    st.session_state['dft_result'] = result
                except Exception as e:
                    st.error(f'計算中にエラーが発生しました: {str(e)}')
        result = st.session_state['dft_result']
        if result is not None:
            # --- カスタムツールチップ用CSSを挿入 ---
            st.markdown("""
<style>
.tooltip {
  position: relative;
  display: inline-block;
  border-bottom: 1px dotted #555;
  cursor: help;
}
.tooltip .tooltiptext {
  visibility: hidden;
  width: 30vw;
  background-color: #222;
  color: #fff;
  text-align: left;
  border-radius: 6px;
  padding: 8px 12px;
  position: absolute;
  z-index: 1;
  top: 100%;
  left: 0;
  opacity: 0;
  transition: opacity 0.3s;
  font-size: 0.7em;
}
.tooltip:hover .tooltiptext {
  visibility: visible;
  opacity: 1;
}
</style>
""", unsafe_allow_html=True)
            st.markdown("---")
            st.subheader('最適化後の分子構造 (XYZ形式)')
            st.text(result['xyz_optimized'])
            # --- 最適化後XYZダウンロードボタン ---
            if input_method == 'SMILESから取得' and 'smiles' in locals() and smiles:
                xyz_filename = f"{smiles}.xyz"
            elif input_method == 'PubChem名/IDから取得' and 'pubchem_query' in locals() and pubchem_query:
                xyz_filename = f"{pubchem_query}.xyz"
            else:
                xyz_filename = "molecule_optimized.xyz"
            st.download_button(
                label=f"最適化後のXYZファイルをダウンロード ({xyz_filename})",
                data=result['xyz_optimized'],
                file_name=xyz_filename,
                mime='text/plain'
            )
            st.markdown("---")
            st.markdown(
                '''<span class="tooltip" style="font-size:1.2em;">分子軌道エネルギー準位図
  <span class="tooltiptext">
    分子軌道エネルギー準位図は、各分子軌道のエネルギーを可視化したものです。青色の線はHOMO（最高被占有分子軌道）、赤色の線はLUMO（最低空分子軌道）を示し、緑色の矢印は電子励起に必要な最小エネルギー差（HOMO-LUMOギャップ）を表します。
  </span>
</span>''',
                unsafe_allow_html=True
            )
            homo_idx = result['mol'].nelectron // 2 - 1
            fig = plot_mo_energies_plotly(result['orbital_energies'], homo_idx, gap=result['gap'])
            st.plotly_chart(fig, use_container_width=True)
            st.markdown("---")
            st.markdown(
                '''<span class="tooltip" style="font-size:1.2em;">Mulliken電荷
  <span class="tooltiptext">
    Mulliken電荷は、各原子における電子の偏り（部分電荷）を示します。正の値は電子が少なく陽性、負の値は電子が多く陰性であることを意味します。棒グラフで各原子の電荷分布を視覚的に比較できます。
  </span>
</span>''',
                unsafe_allow_html=True
            )
            charges_df = pd.DataFrame({
                '原子': atoms,
                '電荷': result['charges']
            })
            import plotly.express as px
            fig_charge = px.bar(charges_df, x='原子', y='電荷', color='電荷', color_continuous_scale='RdBu_r')
            st.plotly_chart(fig_charge, use_container_width=True)
            st.dataframe(charges_df)
            st.markdown("---")
            st.markdown(
                '''<span class="tooltip" style="font-size:1.2em;">IR Spectrum (Vibrational Analysis)
  <span class="tooltiptext">
    IRスペクトル（赤外振動スペクトル）は、分子の振動モードごとの赤外吸収強度と周波数を示します。主なピークは分子内の特定の結合や構造に対応し、分子の構造解析や同定に利用されます。構造最適化が問題なく出来ているかの確認のために行います。エラーを吐いた場合は条件を見直してください。
  </span>
</span>''',
                unsafe_allow_html=True
            )
            ir_result = run_and_plot_ir_spectrum(result['mf_opt'], result['mol'], atoms)
            if ir_result['detail']:
                st.error(f'IRスペクトル計算中にエラーが発生しました: {ir_result["detail"]}')
            else:
                st.text(ir_result['thermo_text'])
                st.image(f"data:image/png;base64,{ir_result['img_base64']}")
                st.markdown('主なIRピークと振動モードの対応')
                if ir_result['mode_df'] is not None:
                    st.dataframe(ir_result['mode_df'], use_container_width=True, height=350)
                else:
                    st.warning("IRスペクトルの詳細データ取得に失敗しました。")
    else:
        st.info('有効な分子構造を入力してください。')
else:
    st.info('有効な分子構造をサイドバーから入力してください。')
