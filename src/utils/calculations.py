import numpy as np
import pandas as pd
import os
import streamlit as st
import time
from scipy.constants import physical_constants
from pyscf import gto, dft, geomopt, lib, tddft

# OpenMP環境変数設定のためのos.environをインポート
import os

def apply_solvent_effects(mf, solvent_settings):
    """DFT計算に溶媒効果を適用する"""
    if not solvent_settings or not solvent_settings.get('enable_solvent', False):
        return mf, None
    
    solvent_model = solvent_settings.get('solvent_model', '')
    selected_solvent = solvent_settings.get('selected_solvent', 'Water')
    epsilon = solvent_settings.get('epsilon', 78.3553)
    
    # 値のチェックと安全な処理
    if not isinstance(epsilon, (int, float)):
        epsilon = 78.3553  # デフォルト値
    
    solvent_message = ""
    try:
        if solvent_model == 'IEF-PCM':
            # PCMモデルの適用
            mf = mf.PCM()
            mf.with_solvent.method = 'IEF-PCM'
            mf.with_solvent.eps = epsilon
            solvent_message = f'IEF-PCM溶媒モデル（誘電率: {epsilon:.4f}）適用'
        elif solvent_model == 'SMD':
            # SMDモデルの適用
            mf = mf.SMD()
            if selected_solvent == "カスタム":
                # カスタム設定の場合はエラーメッセージを表示
                st.warning("SMDモデルではカスタム溶媒設定はサポートされていません。水を使用します。")
                mf.with_solvent.solvent = 'water'
                solvent_message = f'SMD溶媒モデル（溶媒: Water）適用'
            else:
                # 標準溶媒を使用
                solvent_name = selected_solvent.lower()
                mf.with_solvent.solvent = solvent_name
                solvent_message = f'SMD溶媒モデル（溶媒: {selected_solvent}）適用'
    except Exception as e:
        st.error(f"溶媒効果の適用中にエラーが発生しました: {str(e)}")
        st.warning("溶媒効果なしで計算を続行します。")
    
    return mf, solvent_message

def save_xyz_file(atoms, coords, filename='molecule.xyz'):
    """XYZ形式でファイルを保存"""
    os.makedirs('data', exist_ok=True)
    filepath = os.path.join('data', filename)
    with open(filepath, 'w') as f:
        f.write(f"{len(atoms)}\\n")
        f.write("Generated by Molecular DFT App\\n")
        for i, atom in enumerate(atoms):
            f.write(f"{atom} {coords[i][0]:.6f} {coords[i][1]:.6f} {coords[i][2]:.6f}\\n")
    return filepath

def run_dft_calculation(atoms, coords, basis, xc_functional, charge, spin, cpu_cores=None, solvent_settings=None):
    """PySCFを使用したDFT計算を実行"""
    # CPU並列数の設定
    if cpu_cores is None:
        # デフォルト値（セッションから取得）
        cpu_cores = st.session_state.get('num_cpu_cores', 1)
    
    # OpenMP環境変数を明示的に設定
    os.environ['OMP_NUM_THREADS'] = str(cpu_cores)
    
    # PySCF並列設定
    lib.num_threads(cpu_cores)
    
    # 計算設定
    conv_params = {
        'convergence_energy': 1e-6,  # エネルギーの収束閾値 (Eh)
        'convergence_grms': 3e-4,    # 勾配のRMS収束閾値 (Eh/Bohr)
        'convergence_gmax': 4.5e-4,  # 最大勾配の収束閾値 (Eh/Bohr)
        'convergence_drms': 1.2e-3,  # 変位のRMS収束閾値 (Angstrom)
        'convergence_dmax': 1.8e-3   # 最大変位の収束閾値 (Angstrom)
    }
    
    # 分子の準備
    mol_input = []
    for i, atom in enumerate(atoms):
        mol_input.append([atom, coords[i].tolist()])
    
    # メモリ設定（並列計算に合わせて増加）
    mem_per_core = 2000  # コアあたりのメモリ使用量（MB）
    total_memory = mem_per_core * cpu_cores
    
    mol = gto.M(
        atom=mol_input, 
        basis=basis, 
        charge=charge, 
        spin=spin, 
        max_memory=total_memory  # メモリ設定
    )
    
    # 汎関数名の正規化
    xc_functional_normalized = xc_functional.lower()
    
    # 特殊な汎関数の処理
    if xc_functional_normalized == 'wb97x':
        xc_functional_normalized = 'wb97x_v'  # PySCFではwb97xをwb97x_vとして実装
    elif xc_functional_normalized == 'cam-b3lyp':
        xc_functional_normalized = 'camb3lyp'  # PySCFではcam-b3lypをcamb3lypとして実装
    
    # RKSの設定
    mf = dft.RKS(mol)
    mf.xc = xc_functional_normalized
    mf.max_memory = total_memory
    mf.verbose = 4  # より詳細なログを出力
    
    # 溶媒効果の適用（設定されている場合）
    solvent_message = None
    if solvent_settings and solvent_settings.get('enable_solvent', False):
        mf, solvent_message = apply_solvent_effects(mf, solvent_settings)
    
    # SCFオブジェクトを渡して最適化
    mol_opt = geomopt.optimize(mf, conv_params=conv_params)
    
    # 最適化後の計算
    mf_opt = dft.RKS(mol_opt)
    mf_opt.xc = xc_functional_normalized  # 正規化された汎関数名を使用
    mf_opt.max_memory = total_memory
    mf_opt.verbose = 0
    
    # 最適化後も同じ溶媒効果を適用
    if solvent_settings and solvent_settings.get('enable_solvent', False):
        mf_opt, _ = apply_solvent_effects(mf_opt, solvent_settings)
    
    energy = mf_opt.kernel()
    
    # 分子軌道のエネルギー解析
    homo_idx = mol_opt.nelectron // 2 - 1
    lumo_idx = homo_idx + 1
    mo_energy = mf_opt.mo_energy
    homo_energy = mo_energy[homo_idx]
    lumo_energy = mo_energy[lumo_idx]
    gap = lumo_energy - homo_energy
    
    # 結果の整形
    orbital_energies = pd.DataFrame({
        '軌道番号': range(len(mo_energy)),
        'エネルギー (eV)': mo_energy * 27.211386
    })
    
    # 電荷計算
    population = mf_opt.mulliken_pop()
    charges = population[1]
    # 最適化後のxyz文字列を生成
    BOHR_TO_ANGSTROM = 0.529177210903
    atom_syms = [a[0] for a in mol_opt._atom]
    atom_coords = mol_opt.atom_coords() * BOHR_TO_ANGSTROM  # Bohr→Åに変換
    xyz_lines = [f"{atom_syms[i]} {atom_coords[i][0]:.6f} {atom_coords[i][1]:.6f} {atom_coords[i][2]:.6f}" for i in range(len(atom_syms))]
    xyz_optimized = f"{len(atom_syms)}\nOptimized by PySCF\n" + "\n".join(xyz_lines)
    
    # 溶媒設定も結果に含める
    solvent_info = None
    if solvent_settings and solvent_settings.get('enable_solvent', False):
        solvent_info = {
            'model': solvent_settings.get('solvent_model', ''),
            'solvent': solvent_settings.get('selected_solvent', ''),
            'epsilon': solvent_settings.get('epsilon', 0)
        }
        
    return {
        'energy': energy,
        'homo': homo_energy * 27.211386,
        'lumo': lumo_energy * 27.211386,
        'gap': gap * 27.211386,
        'orbital_energies': orbital_energies,
        'charges': charges,
        'mol': mol_opt,
        'xyz_optimized': xyz_optimized,
        'mf_opt': mf_opt,  # 追加: 最適化後のSCFオブジェクト
        'solvent_info': solvent_info  # 溶媒情報を追加
    }

def run_and_plot_ir_spectrum(mf_opt, mol, atoms, solvent_settings=None):
    """IRスペクトルの計算・描画・ピーク表生成を行う"""
    from pyscf.prop import infrared
    from pyscf.hessian import thermo
    from pyscf import lib
    import io
    import base64
    import matplotlib.pyplot as plt
    import sys
    import streamlit as st
    import os
    # apply_solvent_effectsは同じファイル内に統合済み
    
    # 並列計算設定
    cpu_cores = st.session_state.get('num_cpu_cores', 1)
    
    # OpenMP環境変数を明示的に設定
    os.environ['OMP_NUM_THREADS'] = str(cpu_cores)
    
    # PySCF並列設定
    lib.num_threads(cpu_cores)
    
    result = {}
    try:
        # 計算リソース設定
        mem_per_core = 2000  # コアあたりのメモリ使用量（MB）
        total_memory = mem_per_core * cpu_cores
        
        # メモリ設定
        mol.max_memory = total_memory
        mf_opt.max_memory = total_memory
        
        # 溶媒効果の適用（設定されている場合）
        if solvent_settings and solvent_settings.get('enable_solvent', False):
            try:
                mf_opt, _ = apply_solvent_effects(mf_opt, solvent_settings)
                result['solvent_applied'] = True
                
                solvent_model = solvent_settings.get('solvent_model', '')
                selected_solvent = solvent_settings.get('selected_solvent', 'カスタム')
                
                if solvent_model == 'IEF-PCM':
                    if selected_solvent == 'カスタム':
                        epsilon = solvent_settings.get('epsilon', 0.0)
                        if epsilon is not None:
                            result['solvent_info'] = f"IEF-PCM (カスタム, ε={epsilon:.4f})"
                        else:
                            result['solvent_info'] = f"IEF-PCM (カスタム)"
                    else:
                        result['solvent_info'] = f"IEF-PCM ({selected_solvent})"
                elif solvent_model == 'SMD':
                    if selected_solvent == 'カスタム':
                        result['solvent_info'] = f"SMD (Water)"
                    else:
                        result['solvent_info'] = f"SMD ({selected_solvent})"
            except Exception as e:
                st.warning(f"IRスペクトル計算に溶媒効果を適用できませんでした: {str(e)}")
                result['solvent_applied'] = False
        else:
            result['solvent_applied'] = False
        
        # Infraredオブジェクト作成と実行
        mf_ir = infrared.rks.Infrared(mf_opt)
        mf_ir.max_memory = total_memory
        mf_ir = mf_ir.run()
        
        # 標準出力をキャプチャ
        sys_stdout = sys.stdout
        thermo_text = io.StringIO()
        sys.stdout = thermo_text
        try:
            thermo.dump_thermo(mol, thermo.thermo(mf_opt, mf_ir.vib_dict["freq_au"], 298.15, 101325))
        except Exception:
            pass
        sys.stdout = sys_stdout
        result['thermo_text'] = thermo_text.getvalue()
        
        # 振動数のスケーリングファクターとして0.960を適用
        fig, ax, ax2 = mf_ir.plot_ir(w=100, scale=0.960)
        
        # タイトルに汎関数名と溶媒情報を追加
        # 汎関数名の取得と正規化
        functional_name = mf_opt.xc.upper() if hasattr(mf_opt, 'xc') else "B3LYP"
        
        # 表示用に汎関数名を調整
        if functional_name == "WB97X_V":
            functional_name = "ωB97X-V"
        elif functional_name == "CAMB3LYP":
            functional_name = "CAM-B3LYP"
            
        title = f"Infrared Spectrum ({functional_name}, scale=0.960, FWHM=100 cm$^{{-1}}$)"
        if result.get('solvent_applied', False):
            solv_info = result.get('solvent_info', '')
            title += f" - {solv_info}"
        ax.set_title(title)
        
        fig.tight_layout()
        buf = io.BytesIO()
        fig.savefig(buf, format='png')
        buf.seek(0)
        img_base64 = base64.b64encode(buf.read()).decode()
        plt.close(fig)
        result['img_base64'] = img_base64
        
        # IRピークと振動モードの対応表
        freq = mf_ir.vib_dict.get("freq_wavenumber")  # cm^-1
        freq_au = mf_ir.vib_dict.get("freq_au")  # au (atomic unit)
        intensity = getattr(mf_ir, "ir_inten", None)  # IR強度 (km/mol)
        normal_modes = mf_ir.vib_dict.get("norm_mode")
        
        # 熱力学計算のために振動数データを保存
        result['freq'] = freq
        result['freq_au'] = freq_au
        result['vib_dict'] = mf_ir.vib_dict
        
        if freq is not None and intensity is not None and normal_modes is not None:
            mode_info = []
            for idx in range(len(freq)):
                mode_info.append({
                    '周波数 (cm⁻¹)': f"{freq[idx]:.1f}",
                    '強度 (km/mol)': f"{intensity[idx]:.1f}",
                })
            import pandas as pd
            mode_df = pd.DataFrame(mode_info)
            result['mode_df'] = mode_df
        else:
            result['mode_df'] = None
        result['detail'] = None
    except Exception as e:
        result['detail'] = str(e)
    return result


def run_tddft_calculation(mf_opt, mol, n_states=10, solvent_settings=None):
    """
    TDDFT計算を実行し、UV-Visスペクトルを計算する
    
    Args:
        mf_opt: 最適化後のメイン電子状態計算オブジェクト
        mol: 分子オブジェクト
        n_states: 計算する励起状態の数
        solvent_settings: 溶媒効果の設定
        
    Returns:
        dictionary: TDDFT計算結果を含む辞書
    """
    # 並列計算設定
    cpu_cores = st.session_state.get('num_cpu_cores', 1)
    os.environ['OMP_NUM_THREADS'] = str(cpu_cores)
    lib.num_threads(cpu_cores)
    
    # 計算リソース設定
    mem_per_core = 2000  # コアあたりのメモリ使用量（MB）
    total_memory = mem_per_core * cpu_cores
    
    # メモリ設定
    mol.max_memory = total_memory
    mf_opt.max_memory = total_memory
    
    # 溶媒効果の適用（設定されている場合）
    if solvent_settings and solvent_settings.get('enable_solvent', False):
        try:
            mf_opt, _ = apply_solvent_effects(mf_opt, solvent_settings)
        except Exception as e:
            st.warning(f"TDDFT計算に溶媒効果を適用できませんでした: {str(e)}")
    
    start_time = time.time()
    
    # TDDFT計算
    mytd = tddft.TDDFT(mf_opt)
    mytd.nstates = n_states
    mytd.max_memory = total_memory
    
    try:
        # TDDFT計算実行
        mytd.kernel()
        
        # 振動子強度の取得（NaN は 0 に置換）
        osc_strengths = mytd.oscillator_strength()[:n_states]
        osc_strengths = np.nan_to_num(osc_strengths)
        
        # 励起エネルギーをハートリー単位から eV へ変換
        ha_2_ev = physical_constants['Hartree energy in eV'][0]
        energies_ev = mytd.e[:n_states] * ha_2_ev
        
        # 波長（nm）と波数（cm-1）に変換
        energies_nm = 1239.841984 / energies_ev
        energies_cm = 8065.54429 * energies_ev
        
        # 電子状態遷移情報の抽出
        nocc = np.count_nonzero(mf_opt.mo_occ > 0)
        nmo = mf_opt.mo_coeff.shape[1]
        nvirt = nmo - nocc  # 仮想軌道数
        
        transitions = []  # 各要素は (occupied_orbital, virtual_orbital, coefficient)
        for state_idx in range(n_states):
            try:
                xvec_raw = mytd.xy[state_idx][0]
                xvec = np.array(xvec_raw)
                xvec_flat = xvec.flatten()
                max_index = np.argmax(np.abs(xvec_flat))
                max_coeff = xvec_flat[max_index]
                occ_index = max_index // nvirt
                virt_index = max_index % nvirt
                transitions.append((occ_index, nocc + virt_index, max_coeff))
            except Exception as e:
                transitions.append((None, None, None))
        
        # 連続スペクトル作成用のx軸範囲設定
        x_min_eV = 1.5  # 約825 nm
        x_max_eV = 6.5  # 約190 nm
        x_range = np.linspace(x_min_eV, x_max_eV, num=1000)
        
        # コーシー分布の定義
        def cauchy(x, x0, gamma):
            """コーシー分布（正規化済み）"""
            return (1 / np.pi) * (gamma / ((x - x0)**2 + gamma**2))
        
        # 連続スペクトルの作成（コーシー分布の重ね合わせ）
        spectral_width = 0.1  # コーシー分布の幅
        intensity = np.zeros(x_range.size)
        for e, f in zip(energies_ev, osc_strengths):
            intensity += cauchy(x_range, e, spectral_width) * f
        
        # スペクトルの正規化（最大値を1に）
        if np.max(intensity) > 0:
            intensity = intensity / np.max(intensity)
        
        # 結果の辞書を生成
        result = {
            'success': True,
            'calc_time': time.time() - start_time,
            'n_states': n_states,
            'energies_ev': energies_ev,
            'energies_nm': energies_nm,
            'energies_cm': energies_cm,
            'osc_strengths': osc_strengths,
            'transitions': transitions,
            'x_range_ev': x_range,
            'x_range_nm': 1239.841984 / x_range,
            'x_range_cm': 8065.54429 * x_range,
            'intensity': intensity,
            'functional': mf_opt.xc if hasattr(mf_opt, 'xc') else 'Unknown'
        }
        
        return result
    
    except Exception as e:
        return {
            'success': False,
            'error': str(e),
            'calc_time': time.time() - start_time
        }
