import numpy as np
import pandas as pd
import os
import streamlit as st
import time
from scipy.constants import physical_constants
from pyscf import gto, dft, geomopt, lib, tddft

# OpenMP環境変数設定のためのos.environをインポート
import os

def apply_solvent_effects(mf, solvent_settings):
    """DFT計算に溶媒効果を適用する"""
    if not solvent_settings or not solvent_settings.get('enable_solvent', False):
        return mf, None
    
    solvent_model = solvent_settings.get('solvent_model', '')
    selected_solvent = solvent_settings.get('selected_solvent', 'Water')
    epsilon = solvent_settings.get('epsilon', 78.3553)
    
    # 値のチェックと安全な処理
    if not isinstance(epsilon, (int, float)):
        epsilon = 78.3553  # デフォルト値
    
    solvent_message = ""
    try:
        if solvent_model == 'IEF-PCM':
            # PCMモデルの適用
            mf = mf.PCM()
            mf.with_solvent.method = 'IEF-PCM'
            mf.with_solvent.eps = epsilon
            solvent_message = f'IEF-PCM溶媒モデル（誘電率: {epsilon:.4f}）適用'
        elif solvent_model == 'SMD':
            # SMDモデルの適用
            mf = mf.SMD()
            if selected_solvent == "カスタム":
                # カスタム設定の場合はエラーメッセージを表示
                st.warning("SMDモデルではカスタム溶媒設定はサポートされていません。水を使用します。")
                mf.with_solvent.solvent = 'water'
                solvent_message = f'SMD溶媒モデル（溶媒: Water）適用'
            else:
                # 標準溶媒を使用
                solvent_name = selected_solvent.lower()
                mf.with_solvent.solvent = solvent_name
                solvent_message = f'SMD溶媒モデル（溶媒: {selected_solvent}）適用'
    except Exception as e:
        st.error(f"溶媒効果の適用中にエラーが発生しました: {str(e)}")
        st.warning("溶媒効果なしで計算を続行します。")
    
    return mf, solvent_message

def save_xyz_file(atoms, coords, filename='molecule.xyz'):
    """XYZ形式でファイルを保存"""
    os.makedirs('data', exist_ok=True)
    filepath = os.path.join('data', filename)
    with open(filepath, 'w') as f:
        f.write(f"{len(atoms)}\\n")
        f.write("Generated by Molecular DFT App\\n")
        for i, atom in enumerate(atoms):
            f.write(f"{atom} {coords[i][0]:.6f} {coords[i][1]:.6f} {coords[i][2]:.6f}\\n")
    return filepath

def run_dft_calculation(atoms, coords, basis, xc_functional, charge, spin, cpu_cores=None, solvent_settings=None):
    """PySCFを使用したDFT計算を実行"""
    # CPU並列数の設定
    if cpu_cores is None:
        # デフォルト値（セッションから取得）
        cpu_cores = st.session_state.get('num_cpu_cores', 1)
    
    # OpenMP環境変数を明示的に設定
    os.environ['OMP_NUM_THREADS'] = str(cpu_cores)
    
    # PySCF並列設定
    lib.num_threads(cpu_cores)
    
    # 計算設定
    conv_params = {
        'convergence_energy': 1e-6,  # エネルギーの収束閾値 (Eh)
        'convergence_grms': 3e-4,    # 勾配のRMS収束閾値 (Eh/Bohr)
        'convergence_gmax': 4.5e-4,  # 最大勾配の収束閾値 (Eh/Bohr)
        'convergence_drms': 1.2e-3,  # 変位のRMS収束閾値 (Angstrom)
        'convergence_dmax': 1.8e-3   # 最大変位の収束閾値 (Angstrom)
    }
    
    # 分子の準備
    mol_input = []
    for i, atom in enumerate(atoms):
        mol_input.append([atom, coords[i].tolist()])
    
    # メモリ設定（並列計算に合わせて増加）
    mem_per_core = 2000  # コアあたりのメモリ使用量（MB）
    total_memory = mem_per_core * cpu_cores
    
    mol = gto.M(
        atom=mol_input, 
        basis=basis, 
        charge=charge, 
        spin=spin, 
        max_memory=total_memory  # メモリ設定
    )
    
    # 汎関数名の正規化
    xc_functional_normalized = xc_functional.lower()
    
    # 特殊な汎関数の処理
    if xc_functional_normalized == 'wb97x':
        xc_functional_normalized = 'wb97x_v'  # PySCFではwb97xをwb97x_vとして実装
    elif xc_functional_normalized == 'cam-b3lyp':
        xc_functional_normalized = 'camb3lyp'  # PySCFではcam-b3lypをcamb3lypとして実装
    
    # RKSの設定
    mf = dft.RKS(mol)
    mf.xc = xc_functional_normalized
    mf.max_memory = total_memory
    mf.verbose = 4  # より詳細なログを出力
    
    # 溶媒効果の適用（設定されている場合）
    solvent_message = None
    if solvent_settings and solvent_settings.get('enable_solvent', False):
        mf, solvent_message = apply_solvent_effects(mf, solvent_settings)
    
    # SCFオブジェクトを渡して最適化
    mol_opt = geomopt.optimize(mf, conv_params=conv_params)
    
    # 最適化後の計算
    mf_opt = dft.RKS(mol_opt)
    mf_opt.xc = xc_functional_normalized  # 正規化された汎関数名を使用
    mf_opt.max_memory = total_memory
    mf_opt.verbose = 0
    
    # 最適化後も同じ溶媒効果を適用
    if solvent_settings and solvent_settings.get('enable_solvent', False):
        mf_opt, _ = apply_solvent_effects(mf_opt, solvent_settings)
    
    energy = mf_opt.kernel()
    
    # 分子軌道のエネルギー解析
    homo_idx = mol_opt.nelectron // 2 - 1
    lumo_idx = homo_idx + 1
    mo_energy = mf_opt.mo_energy
    homo_energy = mo_energy[homo_idx]
    lumo_energy = mo_energy[lumo_idx]
    gap = lumo_energy - homo_energy
    
    # 結果の整形
    orbital_energies = pd.DataFrame({
        '軌道番号': range(len(mo_energy)),
        'エネルギー (eV)': mo_energy * 27.211386
    })
    
    # 電荷計算
    population = mf_opt.mulliken_pop()
    charges = population[1]
    # 最適化後のxyz文字列を生成
    BOHR_TO_ANGSTROM = 0.529177210903
    atom_syms = [a[0] for a in mol_opt._atom]
    atom_coords = mol_opt.atom_coords() * BOHR_TO_ANGSTROM  # Bohr→Åに変換
    xyz_lines = [f"{atom_syms[i]} {atom_coords[i][0]:.6f} {atom_coords[i][1]:.6f} {atom_coords[i][2]:.6f}" for i in range(len(atom_syms))]
    xyz_optimized = f"{len(atom_syms)}\nOptimized by PySCF\n" + "\n".join(xyz_lines)
    
    # 溶媒設定も結果に含める
    solvent_info = None
    if solvent_settings and solvent_settings.get('enable_solvent', False):
        solvent_info = {
            'model': solvent_settings.get('solvent_model', ''),
            'solvent': solvent_settings.get('selected_solvent', ''),
            'epsilon': solvent_settings.get('epsilon', 0)
        }
        
    return {
        'energy': energy,
        'homo': homo_energy * 27.211386,
        'lumo': lumo_energy * 27.211386,
        'gap': gap * 27.211386,
        'orbital_energies': orbital_energies,
        'charges': charges,
        'mol': mol_opt,
        'xyz_optimized': xyz_optimized,
        'mf_opt': mf_opt,  # 追加: 最適化後のSCFオブジェクト
        'solvent_info': solvent_info  # 溶媒情報を追加
    }

def run_and_plot_ir_spectrum(mf_opt, mol, atoms, solvent_settings=None):
    """IRスペクトルの計算・描画・ピーク表生成を行う"""
    from pyscf.prop import infrared
    from pyscf.hessian import thermo
    from pyscf import lib
    import io
    import base64
    import matplotlib.pyplot as plt
    import sys
    import streamlit as st
    import os
    # apply_solvent_effectsは同じファイル内に統合済み
    
    # 並列計算設定
    cpu_cores = st.session_state.get('num_cpu_cores', 1)
    
    # OpenMP環境変数を明示的に設定
    os.environ['OMP_NUM_THREADS'] = str(cpu_cores)
    
    # PySCF並列設定
    lib.num_threads(cpu_cores)
    
    result = {}
    try:
        # 計算リソース設定
        mem_per_core = 2000  # コアあたりのメモリ使用量（MB）
        total_memory = mem_per_core * cpu_cores
        
        # メモリ設定
        mol.max_memory = total_memory
        mf_opt.max_memory = total_memory
        
        # 溶媒効果の適用（設定されている場合）
        if solvent_settings and solvent_settings.get('enable_solvent', False):
            try:
                mf_opt, _ = apply_solvent_effects(mf_opt, solvent_settings)
                result['solvent_applied'] = True
                
                solvent_model = solvent_settings.get('solvent_model', '')
                selected_solvent = solvent_settings.get('selected_solvent', 'カスタム')
                
                if solvent_model == 'IEF-PCM':
                    if selected_solvent == 'カスタム':
                        epsilon = solvent_settings.get('epsilon', 0.0)
                        if epsilon is not None:
                            result['solvent_info'] = f"IEF-PCM (カスタム, ε={epsilon:.4f})"
                        else:
                            result['solvent_info'] = f"IEF-PCM (カスタム)"
                    else:
                        result['solvent_info'] = f"IEF-PCM ({selected_solvent})"
                elif solvent_model == 'SMD':
                    if selected_solvent == 'カスタム':
                        result['solvent_info'] = f"SMD (Water)"
                    else:
                        result['solvent_info'] = f"SMD ({selected_solvent})"
            except Exception as e:
                st.warning(f"IRスペクトル計算に溶媒効果を適用できませんでした: {str(e)}")
                result['solvent_applied'] = False
        else:
            result['solvent_applied'] = False
        
        # Infraredオブジェクト作成と実行
        mf_ir = infrared.rks.Infrared(mf_opt)
        mf_ir.max_memory = total_memory
        mf_ir = mf_ir.run()
        
        # 標準出力をキャプチャ
        sys_stdout = sys.stdout
        thermo_text = io.StringIO()
        sys.stdout = thermo_text
        try:
            thermo.dump_thermo(mol, thermo.thermo(mf_opt, mf_ir.vib_dict["freq_au"], 298.15, 101325))
        except Exception:
            pass
        sys.stdout = sys_stdout
        result['thermo_text'] = thermo_text.getvalue()
        
        # 振動数のスケーリングファクターとして0.960を適用
        fig, ax, ax2 = mf_ir.plot_ir(w=100, scale=0.960)
        
        # タイトルに汎関数名と溶媒情報を追加
        # 汎関数名の取得と正規化
        functional_name = mf_opt.xc.upper() if hasattr(mf_opt, 'xc') else "B3LYP"
        
        # 表示用に汎関数名を調整
        if functional_name == "WB97X_V":
            functional_name = "ωB97X-V"
        elif functional_name == "CAMB3LYP":
            functional_name = "CAM-B3LYP"
            
        title = f"Infrared Spectrum ({functional_name}, scale=0.960, FWHM=100 cm$^{{-1}}$)"
        if result.get('solvent_applied', False):
            solv_info = result.get('solvent_info', '')
            title += f" - {solv_info}"
        ax.set_title(title)
        
        fig.tight_layout()
        buf = io.BytesIO()
        fig.savefig(buf, format='png')
        buf.seek(0)
        img_base64 = base64.b64encode(buf.read()).decode()
        plt.close(fig)
        result['img_base64'] = img_base64
        
        # IRピークと振動モードの対応表
        freq = mf_ir.vib_dict.get("freq_wavenumber")  # cm^-1
        freq_au = mf_ir.vib_dict.get("freq_au")  # au (atomic unit)
        intensity = getattr(mf_ir, "ir_inten", None)  # IR強度 (km/mol)
        normal_modes = mf_ir.vib_dict.get("norm_mode")
        
        # 熱力学計算のために振動数データを保存
        result['freq'] = freq
        result['freq_au'] = freq_au
        result['vib_dict'] = mf_ir.vib_dict
        
        if freq is not None and intensity is not None and normal_modes is not None:
            mode_info = []
            for idx in range(len(freq)):
                mode_info.append({
                    '周波数 (cm⁻¹)': f"{freq[idx]:.1f}",
                    '強度 (km/mol)': f"{intensity[idx]:.1f}",
                })
            import pandas as pd
            mode_df = pd.DataFrame(mode_info)
            result['mode_df'] = mode_df
        else:
            result['mode_df'] = None
        result['detail'] = None
    except Exception as e:
        result['detail'] = str(e)
    return result


# CIE 1931 XYZ等色関数のデータテーブル（380-780nm）
xBar_yBar_zBar_table = {
    "Wavelength (nm)": [
        380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780
    ],
    "xBar": [
        0.0014,0.0015,0.0016,0.0018,0.0020,0.0022,0.0025,0.0029,0.0033,0.0037,0.0042,0.0048,0.0053,0.0060,0.0068,0.0077,0.0088,0.0100,0.0113,0.0128,0.0143,0.0156,0.0171,0.0188,0.0208,0.0232,0.0263,0.0298,0.0339,0.0384,0.0435,0.0489,0.0550,0.0618,0.0693,0.0776,0.0871,0.0976,0.1089,0.1212,0.1344,0.1497,0.1657,0.1820,0.1985,0.2148,0.2299,0.2445,0.2584,0.2716,0.2839,0.2948,0.3047,0.3136,0.3216,0.3285,0.3343,0.3391,0.3430,0.3461,0.3483,0.3496,0.3501,0.3500,0.3493,0.3481,0.3464,0.3444,0.3420,0.3392,0.3362,0.3333,0.3301,0.3267,0.3229,0.3187,0.3140,0.3089,0.3033,0.2973,0.2908,0.2839,0.2766,0.2687,0.2602,0.2511,0.2406,0.2297,0.2184,0.2069,0.1954,0.1844,0.1735,0.1628,0.1523,0.1421,0.1322,0.1226,0.1133,0.1043,0.0956,0.0873,0.0793,0.0718,0.0646,0.0580,0.0519,0.0463,0.0412,0.0364,0.0320,0.0279,0.0241,0.0207,0.0175,0.0147,0.0121,0.0099,0.0079,0.0063,0.0049,0.0037,0.0029,0.0024,0.0022,0.0024,0.0029,0.0038,0.0052,0.0070,0.0093,0.0122,0.0156,0.0195,0.0240,0.0291,0.0349,0.0412,0.0480,0.0554,0.0633,0.0716,0.0805,0.0898,0.0995,0.1096,0.1202,0.1311,0.1423,0.1538,0.1655,0.1772,0.1891,0.2011,0.2133,0.2257,0.2383,0.2511,0.2640,0.2771,0.2904,0.3039,0.3176,0.3314,0.3455,0.3597,0.3741,0.3886,0.4034,0.4183,0.4334,0.4488,0.4644,0.4801,0.4960,0.5121,0.5283,0.5447,0.5612,0.5778,0.5945,0.6112,0.6280,0.6448,0.6616,0.6784,0.6953,0.7121,0.7288,0.7455,0.7621,0.7785,0.7948,0.8109,0.8268,0.8425,0.8579,0.8731,0.8879,0.9023,0.9163,0.9298,0.9428,0.9553,0.9672,0.9786,0.9894,0.9996,1.0091,1.0181,1.0263,1.0340,1.0410,1.0471,1.0524,1.0567,1.0597,1.0617,1.0628,1.0630,1.0622,1.0608,1.0585,1.0552,1.0509,1.0456,1.0389,1.0313,1.0226,1.0131,1.0026,0.9914,0.9794,0.9665,0.9529,0.9384,0.9232,0.9072,0.8904,0.8728,0.8544,0.8349,0.8148,0.7941,0.7729,0.7514,0.7296,0.7077,0.6858,0.6640,0.6424,0.6217,0.6013,0.5812,0.5614,0.5419,0.5226,0.5035,0.4847,0.4662,0.4479,0.4298,0.4121,0.3946,0.3775,0.3608,0.3445,0.3286,0.3131,0.2980,0.2835,0.2696,0.2562,0.2432,0.2307,0.2187,0.2071,0.1959,0.1852,0.1748,0.1649,0.1554,0.1462,0.1375,0.1291,0.1212,0.1136,0.1065,0.0997,0.0934,0.0874,0.0819,0.0768,0.0721,0.0677,0.0636,0.0598,0.0563,0.0529,0.0498,0.0468,0.0437,0.0408,0.0380,0.0354,0.0329,0.0306,0.0284,0.0264,0.0245,0.0227,0.0211,0.0196,0.0182,0.0170,0.0158,0.0148,0.0138,0.0129,0.0121,0.0114,0.0106,0.0099,0.0093,0.0087,0.0081,0.0076,0.0071,0.0066,0.0062,0.0058,0.0054,0.0051,0.0047,0.0044,0.0041,0.0038,0.0036,0.0033,0.0031,0.0029,0.0027,0.0025,0.0024,0.0022,0.0020,0.0019,0.0018,0.0017,0.0015,0.0014,0.0013,0.0012,0.0012,0.0011,0.0010,0.0009,0.0009,0.0008,0.0007,0.0007,0.0006,0.0006,0.0006,0.0005,0.0005,0.0004,0.0004,0.0004,0.0004,0.0003,0.0003,0.0003,0.0003,0.0003,0.0002,0.0002,0.0002,0.0002,0.0002,0.0002,0.0002,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0000,0.0000,0.0000
    ],
    "yBar": [
        0.0000,0.0000,0.0000,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0002,0.0002,0.0002,0.0002,0.0002,0.0003,0.0003,0.0004,0.0004,0.0004,0.0005,0.0005,0.0006,0.0006,0.0007,0.0008,0.0009,0.0011,0.0012,0.0014,0.0015,0.0017,0.0019,0.0022,0.0025,0.0028,0.0031,0.0035,0.0040,0.0046,0.0052,0.0058,0.0065,0.0073,0.0081,0.0089,0.0098,0.0107,0.0116,0.0126,0.0136,0.0146,0.0157,0.0168,0.0180,0.0192,0.0204,0.0217,0.0230,0.0243,0.0256,0.0270,0.0284,0.0298,0.0313,0.0329,0.0345,0.0362,0.0380,0.0398,0.0418,0.0438,0.0458,0.0480,0.0502,0.0526,0.0550,0.0574,0.0600,0.0626,0.0653,0.0680,0.0709,0.0739,0.0770,0.0803,0.0837,0.0872,0.0910,0.0949,0.0991,0.1034,0.1079,0.1126,0.1175,0.1226,0.1279,0.1334,0.1390,0.1446,0.1504,0.1564,0.1627,0.1693,0.1763,0.1836,0.1913,0.1994,0.2080,0.2171,0.2267,0.2368,0.2474,0.2586,0.2702,0.2824,0.2952,0.3087,0.3230,0.3385,0.3548,0.3717,0.3893,0.4073,0.4256,0.4443,0.4635,0.4830,0.5030,0.5237,0.5447,0.5658,0.5870,0.6082,0.6293,0.6502,0.6707,0.6906,0.7100,0.7280,0.7453,0.7619,0.7778,0.7932,0.8082,0.8225,0.8363,0.8495,0.8620,0.8738,0.8849,0.8955,0.9054,0.9149,0.9237,0.9321,0.9399,0.9472,0.9540,0.9602,0.9660,0.9712,0.9760,0.9803,0.9841,0.9874,0.9904,0.9929,0.9950,0.9967,0.9981,0.9992,0.9998,1.0000,0.9998,0.9993,0.9983,0.9969,0.9950,0.9926,0.9897,0.9865,0.9827,0.9786,0.9741,0.9692,0.9639,0.9581,0.9520,0.9454,0.9385,0.9312,0.9235,0.9154,0.9070,0.8983,0.8892,0.8798,0.8700,0.8598,0.8494,0.8386,0.8276,0.8163,0.8048,0.7931,0.7812,0.7692,0.7570,0.7448,0.7324,0.7200,0.7075,0.6949,0.6822,0.6695,0.6567,0.6439,0.6310,0.6182,0.6053,0.5925,0.5796,0.5668,0.5540,0.5411,0.5284,0.5157,0.5030,0.4905,0.4781,0.4657,0.4534,0.4412,0.4291,0.4170,0.4050,0.3930,0.3810,0.3689,0.3568,0.3447,0.3328,0.3210,0.3094,0.2979,0.2867,0.2757,0.2650,0.2548,0.2450,0.2354,0.2261,0.2170,0.2081,0.1995,0.1911,0.1830,0.1750,0.1672,0.1596,0.1523,0.1451,0.1382,0.1315,0.1250,0.1188,0.1128,0.1070,0.1015,0.0962,0.0911,0.0863,0.0816,0.0771,0.0728,0.0687,0.0648,0.0610,0.0574,0.0539,0.0507,0.0475,0.0446,0.0418,0.0391,0.0366,0.0342,0.0320,0.0300,0.0281,0.0263,0.0247,0.0232,0.0218,0.0205,0.0193,0.0181,0.0170,0.0159,0.0148,0.0138,0.0128,0.0119,0.0111,0.0103,0.0095,0.0088,0.0082,0.0076,0.0071,0.0066,0.0061,0.0057,0.0053,0.0050,0.0047,0.0044,0.0041,0.0038,0.0036,0.0034,0.0031,0.0029,0.0027,0.0026,0.0024,0.0022,0.0021,0.0020,0.0018,0.0017,0.0016,0.0015,0.0014,0.0013,0.0012,0.0011,0.0010,0.0010,0.0009,0.0008,0.0008,0.0007,0.0007,0.0006,0.0006,0.0006,0.0005,0.0005,0.0004,0.0004,0.0004,0.0004,0.0003,0.0003,0.0003,0.0003,0.0002,0.0002,0.0002,0.0002,0.0002,0.0002,0.0002,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000
    ],
    "zBar": [
        0.0065,0.0070,0.0077,0.0085,0.0094,0.0105,0.0120,0.0136,0.0155,0.0177,0.0201,0.0225,0.0252,0.0284,0.0320,0.0362,0.0415,0.0473,0.0536,0.0605,0.0679,0.0741,0.0810,0.0891,0.0988,0.1102,0.1249,0.1418,0.1612,0.1830,0.2074,0.2334,0.2625,0.2949,0.3311,0.3713,0.4170,0.4673,0.5221,0.5815,0.6456,0.7201,0.7980,0.8780,0.9588,1.0391,1.1141,1.1868,1.2566,1.3230,1.3856,1.4419,1.4939,1.5414,1.5844,1.6230,1.6561,1.6848,1.7094,1.7301,1.7471,1.7599,1.7695,1.7763,1.7805,1.7826,1.7833,1.7823,1.7800,1.7765,1.7721,1.7688,1.7647,1.7593,1.7525,1.7441,1.7335,1.7208,1.7060,1.6889,1.6692,1.6473,1.6226,1.5946,1.5632,1.5281,1.4849,1.4386,1.3897,1.3392,1.2876,1.2382,1.1887,1.1394,1.0904,1.0419,0.9943,0.9474,0.9015,0.8567,0.8130,0.7706,0.7296,0.6902,0.6523,0.6162,0.5825,0.5507,0.5205,0.4920,0.4652,0.4399,0.4162,0.3939,0.3730,0.3533,0.3349,0.3176,0.3014,0.2862,0.2720,0.2588,0.2464,0.2346,0.2233,0.2123,0.2010,0.1899,0.1790,0.1685,0.1582,0.1481,0.1384,0.1290,0.1201,0.1117,0.1040,0.0968,0.0901,0.0839,0.0782,0.0733,0.0687,0.0646,0.0608,0.0573,0.0539,0.0507,0.0477,0.0449,0.0422,0.0395,0.0369,0.0344,0.0321,0.0298,0.0277,0.0257,0.0238,0.0220,0.0203,0.0187,0.0172,0.0159,0.0146,0.0134,0.0123,0.0113,0.0104,0.0095,0.0087,0.0080,0.0074,0.0068,0.0062,0.0057,0.0053,0.0049,0.0045,0.0042,0.0039,0.0036,0.0034,0.0031,0.0029,0.0027,0.0026,0.0024,0.0023,0.0022,0.0021,0.0020,0.0019,0.0019,0.0018,0.0018,0.0018,0.0017,0.0017,0.0017,0.0017,0.0016,0.0016,0.0015,0.0015,0.0014,0.0013,0.0013,0.0012,0.0012,0.0011,0.0011,0.0011,0.0010,0.0010,0.0010,0.0010,0.0009,0.0009,0.0008,0.0008,0.0008,0.0007,0.0007,0.0006,0.0006,0.0005,0.0005,0.0004,0.0004,0.0003,0.0003,0.0003,0.0003,0.0003,0.0002,0.0002,0.0002,0.0002,0.0002,0.0002,0.0002,0.0002,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000
    ]
}

# sRGB変換用行列（D65基準）
rgb_conversion_matrix = np.array([
    [ 3.2406, -1.5372, -0.4986],
    [-0.9689,  1.8758,  0.0415],
    [ 0.0557, -0.2040,  1.0570]
])

def gamma_correction(value):
    """リニアRGB(0~1)をガンマ補正して sRGB(0~1) に変換する"""
    if value <= 0.0031308:
        return 12.92 * value
    else:
        return 1.055 * (value ** (1/2.4)) - 0.055

def calculate_molecule_color(tddft_result, multiplier=1.0):
    """
    TDDFT計算結果から分子の色を計算する
    
    Args:
        tddft_result: TDDFT計算結果の辞書
        multiplier: 吸光度の強度倍率
        
    Returns:
        dictionary: 色計算結果を含む辞書
    """
    import io
    import base64
    import matplotlib.pyplot as plt
    from scipy.interpolate import interp1d
    
    try:
        if not tddft_result.get('success', False):
            return {
                'success': False,
                'error': '有効なTDDFT計算結果がありません'
            }
        
        # 波長範囲の設定（380nm-780nm、1nm間隔）
        wavelength_range = np.linspace(380, 780, 401)
        
        # 等色関数のデータ準備
        cie_wavelength = np.array(xBar_yBar_zBar_table["Wavelength (nm)"])
        xBar_values = np.array(xBar_yBar_zBar_table["xBar"])
        yBar_values = np.array(xBar_yBar_zBar_table["yBar"])
        zBar_values = np.array(xBar_yBar_zBar_table["zBar"])
        
        # 補間関数の作成（スプライン補間よりも高速な線形補間を使用）
        xBar_interp = interp1d(cie_wavelength, xBar_values, kind='linear', bounds_error=False, fill_value=0.0)
        yBar_interp = interp1d(cie_wavelength, yBar_values, kind='linear', bounds_error=False, fill_value=0.0)
        zBar_interp = interp1d(cie_wavelength, zBar_values, kind='linear', bounds_error=False, fill_value=0.0)
        
        # 補間値の計算
        xBar_spline = xBar_interp(wavelength_range)
        yBar_spline = yBar_interp(wavelength_range)
        zBar_spline = zBar_interp(wavelength_range)
        
        # 参照用の積分値（全透過の場合）の計算
        X_ref = np.trapz(xBar_spline, wavelength_range)
        Y_ref = np.trapz(yBar_spline, wavelength_range)
        Z_ref = np.trapz(zBar_spline, wavelength_range)
        
        # TDDFTの結果から透過率を計算
        # TDDFTスペクトル強度は吸収に対応するため、これを透過率に変換する
        # Beer-Lambertの法則: A = ε·c·l、ここでA = log10(I0/I)
        # 透過率 T = I/I0 = 10^(-A) = 10^(-ε·c·l)
        absorption = np.zeros_like(wavelength_range)
        
        # まずTDDFT計算から吸収スペクトルを適切に取得する
        if 'x_range_nm' in tddft_result and 'intensity' in tddft_result:
            # 波長(nm)とスペクトル強度データを取得
            tddft_wavelength = np.array(tddft_result['x_range_nm'])
            tddft_intensity = np.array(tddft_result['intensity'])
            
            # 380-780nmの可視光範囲にあるデータのみ使用
            mask = (tddft_wavelength >= 380) & (tddft_wavelength <= 780)
            
            if np.any(mask):
                # 可視光範囲内のデータがある場合
                valid_wavelength = tddft_wavelength[mask]
                valid_intensity = tddft_intensity[mask]
                
                # 吸収スペクトルを直接利用するため線形補間
                absorption_interp = interp1d(valid_wavelength, valid_intensity, 
                                          kind='linear', bounds_error=False, 
                                          fill_value=0.0)
                
                # 全波長範囲に対して補間した吸収スペクトルを取得
                absorption = absorption_interp(wavelength_range)
                
                # スペクトルの強度を調整（最大値が1になるよう正規化）
                max_abs = np.max(absorption)
                if max_abs > 0:
                    absorption = absorption / max_abs
            else:
                # 可視光範囲内のスペクトル強度データがない場合は個別の励起状態から再構築
                for energy_nm, osc_strength in zip(tddft_result['energies_nm'], tddft_result['osc_strengths']):
                    if 380 <= energy_nm <= 780 and osc_strength > 0.001:  # 可視光領域の強度が意味のある励起状態のみ
                        # ガウス分布でピークを表現（幅を調整）
                        sigma = 15  # バンド幅を調整（小さいほど鋭いピーク）
                        # 各波長でのガウス分布の寄与を計算
                        absorption += osc_strength * np.exp(-(wavelength_range - energy_nm)**2 / (2 * sigma**2))
        else:
            # x_range_nmやintensityがない場合は個別の励起状態から直接構築
            for energy_nm, osc_strength in zip(tddft_result['energies_nm'], tddft_result['osc_strengths']):
                if 380 <= energy_nm <= 780 and osc_strength > 0.001:
                    # より鋭いピークを使用
                    sigma = 15  # 鋭いピーク用にバンド幅を調整
                    absorption += osc_strength * np.exp(-(wavelength_range - energy_nm)**2 / (2 * sigma**2))
        
        # 吸収データがゼロの場合の対策
        if np.max(absorption) > 0:
            # 正規化（最大値を1に）
            absorption = absorption / np.max(absorption)
        
        # multiplierは溶液の濃度や光路長に相当するパラメータとして扱う
        # Beer-Lambertの法則に従って透過率を計算: T = 10^(-A·c·l)
        # ここで multiplier は c·l に相当
        transmittance = 10**(-absorption * multiplier)
        
        # 色空間変換のための計算
        # 各等色関数と透過率の積を計算
        xBar_times_transmittance = xBar_spline * transmittance
        yBar_times_transmittance = yBar_spline * transmittance
        zBar_times_transmittance = zBar_spline * transmittance
        
        # XYZ値の計算（積分）
        X = np.trapz(xBar_times_transmittance, wavelength_range)
        Y = np.trapz(yBar_times_transmittance, wavelength_range)
        Z = np.trapz(zBar_times_transmittance, wavelength_range)
        
        # XYZ値の正規化（全透過の積分値で割る）
        X = X / X_ref
        Y = Y / Y_ref
        Z = Z / Z_ref
        
        # XYZ → リニアRGB変換
        linear_rgb = np.dot(rgb_conversion_matrix, [X, Y, Z])
        
        # 負の値を0にクリップ
        linear_rgb = np.clip(linear_rgb, 0, None)
        
        # ガンマ補正（リニアRGB → sRGB）
        srgb = np.array([gamma_correction(val) for val in linear_rgb])
        
        # 0-255の範囲にスケーリング
        rgb_255 = np.clip(srgb * 255.0, 0, 255)
        
        # HEX色コードの生成
        rgb_hex = f'#{int(rgb_255[0]):02x}{int(rgb_255[1]):02x}{int(rgb_255[2]):02x}'
        
        # 色の可視化用画像生成
        fig, ax = plt.subplots(figsize=(2, 2))
        color_img = np.ones((100, 100, 3))
        for i in range(3):
            color_img[:, :, i] = srgb[i]
        ax.imshow(color_img)
        ax.axis('off')
        
        buf = io.BytesIO()
        fig.savefig(buf, format='png', bbox_inches='tight', pad_inches=0)
        buf.seek(0)
        color_img_base64 = base64.b64encode(buf.read()).decode()
        plt.close(fig)
        
        # 結果の辞書を作成
        result = {
            'success': True,
            'rgb': rgb_255.tolist(),
            'rgb_hex': rgb_hex,
            'xyz': [X, Y, Z],
            'color_img': color_img_base64,
            'wavelength_range': wavelength_range.tolist(),
            'transmittance': transmittance.tolist(),
            'xBar': xBar_spline.tolist(),
            'yBar': yBar_spline.tolist(),
            'zBar': zBar_spline.tolist(),
            'absorption': absorption.tolist(),
            'multiplier': multiplier
        }
        
        return result
        
    except Exception as e:
        import traceback
        return {
            'success': False,
            'error': str(e),
            'traceback': traceback.format_exc()
        }

def run_tddft_calculation(mf_opt, mol, n_states=10, solvent_settings=None):
    """
    TDDFT計算を実行し、UV-Visスペクトルを計算する
    
    Args:
        mf_opt: 最適化後のメイン電子状態計算オブジェクト
        mol: 分子オブジェクト
        n_states: 計算する励起状態の数
        solvent_settings: 溶媒効果の設定
        
    Returns:
        dictionary: TDDFT計算結果を含む辞書
    """
    # 並列計算設定
    cpu_cores = st.session_state.get('num_cpu_cores', 1)
    os.environ['OMP_NUM_THREADS'] = str(cpu_cores)
    lib.num_threads(cpu_cores)
    
    # 計算リソース設定
    mem_per_core = 2000  # コアあたりのメモリ使用量（MB）
    total_memory = mem_per_core * cpu_cores
    
    # メモリ設定
    mol.max_memory = total_memory
    mf_opt.max_memory = total_memory
    
    # 溶媒効果の適用（設定されている場合）
    if solvent_settings and solvent_settings.get('enable_solvent', False):
        try:
            mf_opt, _ = apply_solvent_effects(mf_opt, solvent_settings)
        except Exception as e:
            st.warning(f"TDDFT計算に溶媒効果を適用できませんでした: {str(e)}")
    
    start_time = time.time()
    
    # TDDFT計算
    mytd = tddft.TDDFT(mf_opt)
    mytd.nstates = n_states
    mytd.max_memory = total_memory
    
    try:
        # TDDFT計算実行
        mytd.kernel()
        
        # 振動子強度の取得（NaN は 0 に置換）
        osc_strengths = mytd.oscillator_strength()[:n_states]
        osc_strengths = np.nan_to_num(osc_strengths)
        
        # 励起エネルギーをハートリー単位から eV へ変換
        ha_2_ev = physical_constants['Hartree energy in eV'][0]
        energies_ev = mytd.e[:n_states] * ha_2_ev
        
        # 波長（nm）と波数（cm-1）に変換
        energies_nm = 1239.841984 / energies_ev
        energies_cm = 8065.54429 * energies_ev
        
        # 電子状態遷移情報の抽出
        nocc = np.count_nonzero(mf_opt.mo_occ > 0)
        nmo = mf_opt.mo_coeff.shape[1]
        nvirt = nmo - nocc  # 仮想軌道数
        
        transitions = []  # 各要素は (occupied_orbital, virtual_orbital, coefficient)
        for state_idx in range(n_states):
            try:
                xvec_raw = mytd.xy[state_idx][0]
                xvec = np.array(xvec_raw)
                xvec_flat = xvec.flatten()
                max_index = np.argmax(np.abs(xvec_flat))
                max_coeff = xvec_flat[max_index]
                occ_index = max_index // nvirt
                virt_index = max_index % nvirt
                transitions.append((occ_index, nocc + virt_index, max_coeff))
            except Exception as e:
                transitions.append((None, None, None))
        
        # 連続スペクトル作成用のx軸範囲設定
        x_min_eV = 1.5  # 約825 nm
        x_max_eV = 6.5  # 約190 nm
        x_range = np.linspace(x_min_eV, x_max_eV, num=1000)
        
        # コーシー分布の定義
        def cauchy(x, x0, gamma):
            """コーシー分布（正規化済み）"""
            return (1 / np.pi) * (gamma / ((x - x0)**2 + gamma**2))
        
        # 連続スペクトルの作成（コーシー分布の重ね合わせ）
        spectral_width = 0.1  # コーシー分布の幅
        intensity = np.zeros(x_range.size)
        for e, f in zip(energies_ev, osc_strengths):
            intensity += cauchy(x_range, e, spectral_width) * f
        
        # スペクトルの正規化（最大値を1に）
        if np.max(intensity) > 0:
            intensity = intensity / np.max(intensity)
        
        # 結果の辞書を生成
        result = {
            'success': True,
            'calc_time': time.time() - start_time,
            'n_states': n_states,
            'energies_ev': energies_ev,
            'energies_nm': energies_nm,
            'energies_cm': energies_cm,
            'osc_strengths': osc_strengths,
            'transitions': transitions,
            'x_range_ev': x_range,
            'x_range_nm': 1239.841984 / x_range,
            'x_range_cm': 8065.54429 * x_range,
            'intensity': intensity,
            'functional': mf_opt.xc if hasattr(mf_opt, 'xc') else 'Unknown'
        }
        
        return result
    
    except Exception as e:
        return {
            'success': False,
            'error': str(e),
            'calc_time': time.time() - start_time
        }
