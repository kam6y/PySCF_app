import numpy as np
import pandas as pd
from pyscf import gto, dft, geomopt
import os

def save_xyz_file(atoms, coords, filename='molecule.xyz'):
    """XYZ形式でファイルを保存"""
    os.makedirs('data', exist_ok=True)
    filepath = os.path.join('data', filename)
    with open(filepath, 'w') as f:
        f.write(f"{len(atoms)}\\n")
        f.write("Generated by Molecular DFT App\\n")
        for i, atom in enumerate(atoms):
            f.write(f"{atom} {coords[i][0]:.6f} {coords[i][1]:.6f} {coords[i][2]:.6f}\\n")
    return filepath

def run_dft_calculation(atoms, coords, basis, xc_functional, charge, spin):
    """PySCFを使用したDFT計算を実行"""
    conv_params = {
        'convergence_energy': 1e-6,  # エネルギーの収束閾値 (Eh)
        'convergence_grms': 3e-4,    # 勾配のRMS収束閾値 (Eh/Bohr)
        'convergence_gmax': 4.5e-4,  # 最大勾配の収束閾値 (Eh/Bohr)
        'convergence_drms': 1.2e-3,  # 変位のRMS収束閾値 (Angstrom)
        'convergence_dmax': 1.8e-3   # 最大変位の収束閾値 (Angstrom)
    }
    mol_input = []
    for i, atom in enumerate(atoms):
        mol_input.append([atom, coords[i].tolist()])
    mol = gto.M(atom=mol_input, basis=basis, charge=charge, spin=spin)
    mf = dft.RKS(mol)
    mf.xc = xc_functional
    # SCFオブジェクトを渡して最適化
    mol_opt = geomopt.optimize(mf, conv_params=conv_params)
    mf_opt = dft.RKS(mol_opt)
    mf_opt.xc = xc_functional
    mf_opt.verbose = 0
    energy = mf_opt.kernel()
    homo_idx = mol_opt.nelectron // 2 - 1
    lumo_idx = homo_idx + 1
    mo_energy = mf_opt.mo_energy
    homo_energy = mo_energy[homo_idx]
    lumo_energy = mo_energy[lumo_idx]
    gap = lumo_energy - homo_energy
    orbital_energies = pd.DataFrame({
        '軌道番号': range(len(mo_energy)),
        'エネルギー (eV)': mo_energy * 27.211386
    })
    population = mf_opt.mulliken_pop()
    charges = population[1]
    # 最適化後のxyz文字列を生成
    BOHR_TO_ANGSTROM = 0.529177210903
    atom_syms = [a[0] for a in mol_opt._atom]
    atom_coords = mol_opt.atom_coords() * BOHR_TO_ANGSTROM  # Bohr→Åに変換
    xyz_lines = [f"{atom_syms[i]} {atom_coords[i][0]:.6f} {atom_coords[i][1]:.6f} {atom_coords[i][2]:.6f}" for i in range(len(atom_syms))]
    xyz_optimized = f"{len(atom_syms)}\nOptimized by PySCF\n" + "\n".join(xyz_lines)
    return {
        'energy': energy,
        'homo': homo_energy * 27.211386,
        'lumo': lumo_energy * 27.211386,
        'gap': gap * 27.211386,
        'orbital_energies': orbital_energies,
        'charges': charges,
        'mol': mol_opt,
        'xyz_optimized': xyz_optimized,
        'mf_opt': mf_opt  # 追加: 最適化後のSCFオブジェクト
    }

def run_and_plot_ir_spectrum(mf_opt, mol, atoms):
    """IRスペクトルの計算・描画・ピーク表生成を行う"""
    from pyscf.prop import infrared
    from pyscf.hessian import thermo
    import io
    import base64
    import matplotlib.pyplot as plt
    import sys
    result = {}
    try:
        mf_ir = infrared.rks.Infrared(mf_opt).run()
        sys_stdout = sys.stdout
        thermo_text = io.StringIO()
        sys.stdout = thermo_text
        try:
            thermo.dump_thermo(mol, thermo.thermo(mf_opt, mf_ir.vib_dict["freq_au"], 298.15, 101325))
        except Exception:
            pass
        sys.stdout = sys_stdout
        result['thermo_text'] = thermo_text.getvalue()
        # 振動数のスケーリングファクターとして0.960を適用
        fig, ax, ax2 = mf_ir.plot_ir(w=100, scale=0.960)
        ax.set_title("Infrared Spectrum (B3LYP, scale=0.960, FWHM=100 cm$^{-1}$)")
        fig.tight_layout()
        buf = io.BytesIO()
        fig.savefig(buf, format='png')
        buf.seek(0)
        img_base64 = base64.b64encode(buf.read()).decode()
        plt.close(fig)
        result['img_base64'] = img_base64
        # IRピークと振動モードの対応表
        freq = mf_ir.vib_dict.get("freq_wavenumber")  # cm^-1
        intensity = getattr(mf_ir, "ir_inten", None)  # IR強度 (km/mol)
        normal_modes = mf_ir.vib_dict.get("norm_mode")
        if freq is not None and intensity is not None and normal_modes is not None:
            mode_info = []
            for idx in range(len(freq)):
                mode_info.append({
                    '周波数 (cm⁻¹)': f"{freq[idx]:.1f}",
                    '強度 (km/mol)': f"{intensity[idx]:.1f}",
                })
            import pandas as pd
            mode_df = pd.DataFrame(mode_info)
            result['mode_df'] = mode_df
        else:
            result['mode_df'] = None
        result['detail'] = None
    except Exception as e:
        result['detail'] = str(e)
    return result
